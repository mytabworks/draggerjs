module.exports=function(t){var e={};function n(o){if(e[o])return e[o].exports;var i=e[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(o,i,function(e){return t[e]}.bind(null,i));return o},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=0)}([function(t,e,n){"use strict";n.r(e),n.d(e,"default",(function(){return X}));const o=window,i=document,r=!!i.documentElement.setPointerCapture,a={allowBoundContainer:!0,allowExactTargetDraggable:!1,autoscroll:!1,autoscrollSensitivity:20,eventListenerOption:!1},l=o.requestAnimationFrame||o.webkitRequestAnimationFrame||o.mozRequestAnimationFrame,s=o.cancelAnimationFrame||o.webkitCancelAnimationFrame||o.mozCancelAnimationFrame,c=(t,e)=>{Object.keys(e).forEach(n=>{n in t.style&&(t.style[n]=e[n])})},p=t=>"string"==typeof t,d=t=>"function"==typeof t,u=t=>t&&t.nodeType===Node.ELEMENT_NODE,g=(t,e,n,o)=>{e.split(/\s{1,10}/).forEach(e=>{t.addEventListener(e,n,o)})},h=(t,e,n,o)=>{e.split(/\s{1,10}/).forEach(e=>{t.removeEventListener(e,n,o)})},m=(t,e,n)=>{if(!(e.includes(typeof t)||e.includes("node")&&u(t)))throw new Error(`${n} must contain the following data types (${e.map(t=>t.toUpperCase()).join(", ")})`)},f=["dragstart","dragmove","dragend","dragenter","dragover","dragexit","drop"],b=(t,e)=>{if(!f.includes(e))throw new SyntaxError(`Dragger.${t} event type "${e}" is not recognize. supported events are ${f.join(", ")}`)};class y{constructor(t,e){var n,o,i;i=void 0,(o="originalEvent")in(n=this)?Object.defineProperty(n,o,{value:i,enumerable:!0,configurable:!0,writable:!0}):n[o]=i,Object.assign(this,e),this.originalEvent=t}preventDefault(){this.originalEvent.preventDefault()}stopPropagation(){this.originalEvent.stopPropagation()}}const v=(t,{x:e,y:n,axis:o})=>{const i={position:"absolute"};"x"!==o&&o||(i.left=e+"px"),"y"!==o&&o||(i.top=n+"px"),c(t,i)},x=(t,{container:e,isDraggable:n,initialPosition:o,allowBoundContainer:i})=>{let{clientX:r,clientY:a}=t.touches&&t.touches[0]||t;const l=e.getBoundingClientRect();let s=r,c=a;return i&&(s=E(e.scrollLeft+(s-l.left)-(n?o.left:0),o),c=D(e.scrollTop+(c-l.top)-(n?o.top:0),o)),{clientX:r,clientY:a,x:s,y:c}},w=({target:t,droppableQuery:e,point:{x:n,y:o}})=>{t.hidden=!0;const r=i.elementFromPoint(n,o);t.hidden=!1;const a=r&&r.closest(e),l=a&&a.matches(e);return{droppableTarget:r,srcDropable:a,isOverDroppable:l}},D=(t,e)=>Math.max(0,Math.min(e.containerHeight-e.height,t)),E=(t,e)=>Math.max(0,Math.min(e.containerWidth-e.width,t)),O=(t,e,n)=>Math.min(t,Math.min(e,n>0?n:e)),P=(t,{y:e,x:n,clientY:o,clientX:r,target:a,container:p,sensitivity:d,initialPosition:u})=>{t.animationFrame&&s(t.animationFrame);const g=()=>{const s=p.getBoundingClientRect();(t=>{const e=[];for(let n=t;n&&n!==i;n=n.parentNode)(n.scrollHeight>n.clientHeight||n.scrollWidth>n.clientWidth)&&e.push(n);return e})(p).reduce((t,i,l,g)=>{const{top:h,left:m}="HTML"!==i.nodeName?i.getBoundingClientRect():{top:0,left:0};let{scrollTop:f,scrollLeft:b,scrollHeight:y,scrollWidth:v,clientHeight:x,clientWidth:w}=i;const P={},T=i===p,X=h+d,Y=h+x-d,j=m+d,C=m+w-d,F=X-o,H=o-Y,M=j-r,A=r-C,L=e+u.top,S=n+u.left,B=s.top,W=s.top+s.height,_=s.left,R=s.left+s.width,$=o<X&&f>0&&(T?L>0:o>B),k=o>Y&&f<y-x&&(T?L<y:o<W),N=r<j&&b>0&&(T?S>0:r>_),q=r>C&&b<v-w&&(T?S<v:r<R),z=$||k||N||q;if($){const t=O(d,F,T?L-d:o-B);f-=t,e-=t,P.top=D(e,u)+"px"}else if(k){const t=O(d,H,T?y-L:W-o);f+=t,e+=t,P.top=D(e,u)+"px"}if(N){const t=O(d,M,T?S-d:r-_);b-=t,n-=t,P.left=E(n,u)+"px"}else if(q){const t=O(d,A,T?v-S:R-r);b+=t,n+=t,P.left=E(n,u)+"px"}return z&&(i.scrollTop=f,i.scrollLeft=b,c(a,P),g.splice(1)),t||z},!1)&&(t.animationFrame=l(g))};t.animationFrame=l(g)};function T(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}class X{static create(...t){return new X(...t)}constructor(t,e){var n;T(this,"container",void 0),T(this,"options",void 0),T(this,"emitters",{}),T(this,"modifiers",void 0),T(this,"pluginDumps",void 0),T(this,"initHandler",void 0),this.container=p(t)?(n=t,i.querySelector(n)):u(t)?t:i.body,this.options={...a,...e},Object.keys(this.options).forEach(t=>{m(this.options[t],["autoscrollSensitivity"===t?"number":["droppable","draggable","axis"].includes(t)?"string":"boolean"],`Dragger options \`${t}\``)}),m(t,["string","node"],"Dragger argument `0`"),m(this.container,["node"],"Dragger this.container is null check carefully what you input in argument `0`"),this.init()}init(){const t=this.container,{axis:e,draggable:n,droppable:o,allowBoundContainer:i,allowExactTargetDraggable:a,autoscroll:l,autoscrollSensitivity:s,eventListenerOption:p}=this.options;this.initHandler=u=>{const m={},{dragstart:f,dragmove:b,dragend:D,dragenter:E,dragover:O,dragexit:T,drop:X}=this.emitters,Y=!a&&u.target.closest(n)||u.target,j=!!n&&Y.matches(n),C=((t,{target:e,container:n,isDraggable:o})=>{const{clientX:i,clientY:r}=t.touches&&t.touches[0]||t,{left:a=0,top:l=0,width:s=0,height:c=0}=o?e.getBoundingClientRect():{};return{left:i-a,top:r-l,width:s,height:c,containerHeight:n.scrollHeight,containerWidth:n.scrollWidth}})(u,{target:Y,container:t,isDraggable:j}),F={container:t,isDraggable:j,allowBoundContainer:i,initialPosition:C},{x:H,y:M,...A}=x(u,F),L={type:"dragstart",target:Y,container:t,isDraggableElement:j,startX:H,startY:M,moveX:H,moveY:M,endX:H,endY:M,clientX:A.clientX,clientY:A.clientY};d(f)&&f.call(t,new y(u,L)),j&&v(Y,{x:H,y:M,axis:e}),r&&Y.setPointerCapture(u.pointerId);const S=n=>{const{clientX:i,clientY:r,...a}=x(n,F);L.clientX=i,L.clientY=r;let c=L.moveX=L.endX=a.x,p=L.moveY=L.endY=a.y;if(j&&(v(Y,{x:c,y:p,axis:e}),l&&P(m,{target:Y,container:t,x:c,y:p,clientX:i,clientY:r,sensitivity:s,initialPosition:C}),o)){const{srcDropable:e,droppableTarget:i,isOverDroppable:r}=w({target:Y,droppableQuery:o,point:{x:L.clientX,y:L.clientY}});r&&(m.droppableAt!==e&&(d(E)&&E.call(e,new y(n,{...L,type:"dragenter",srcDropable:e,droppableTarget:i})),m.droppableAt&&d(T)&&T.call(e,new y(n,{...L,type:"dragexit",srcDropable:m.droppableAt}))),m.droppableAt=e,d(O)&&O.call(t,new y(n,{...L,type:"dragover",srcDropable:e,droppableTarget:i})))}d(b)&&b.call(t,new y(n,{...L,type:"dragmove"}))};g(t,r?"pointermove":"mousemove touchmove",S,p);const B=e=>{if(l&&m.animationFrame&&cancelAnimationFrame(m.animationFrame),o&&j){j&&c(Y,{position:null,left:null,top:null});const{srcDropable:t,droppableTarget:n,isOverDroppable:i}=w({target:Y,droppableQuery:o,point:{x:L.clientX,y:L.clientY}});i&&d(X)&&X.call(t,new y(e,{...L,type:"drop",srcDropable:t,droppableTarget:n}))}d(D)&&D.call(t,new y(e,{...L,type:"dragend"})),r&&Y.releasePointerCapture(e.pointerId),h(t,r?"pointermove":"mousemove touchmove",S,p),h(t,r?"pointerup":"mouseup touchend",B,p)};g(t,r?"pointerup":"mouseup touchend",B,p)},g(t,r?"pointerdown":"mousedown touchstart",this.initHandler,p)}on(t,e){b("on",t),this.emitters[t]=e}off(t){b("off",t),delete this.emitters[t]}destroy(){h(this.container,r?"pointerdown":"mousedown touchstart",this.initHandler,this.options.eventListenerOption)}}}]);